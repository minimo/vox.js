<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
</head>
<body>

<canvas id="c" width="500" height="500"></canvas>

<script src="https://cdn.rawgit.com/mrdoob/three.js/r71/build/three.min.js"></script>
<script src="../build/vox.js"></script>
<script>

window.onload = function() {
    var updateListeners = [];
    var update = function(frame) {
        updateListeners.forEach(function(listener) {
            listener(frame);
        });
    };
    
    var scene = new THREE.Scene();

    var camera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
    var cameraTarget = new THREE.Vector3(0, 0, 0);
    updateListeners.push(function(frame) {
        camera.position.x = Math.cos(frame * 0.004) * 100;
        camera.position.y = 50;
        camera.position.z = Math.sin(frame * 0.004) * 100;
        camera.lookAt(cameraTarget);
    });
    
    var directionalLight = new THREE.DirectionalLight(0xffffff);
    updateListeners.push(function(frame) {
        directionalLight.position.x = Math.cos(frame * -0.001) * 100;
        directionalLight.position.y = 100;
        directionalLight.position.z = Math.sin(frame * -0.001) * 100;
    });
    scene.add(directionalLight);

    var ambientLight = new THREE.AmbientLight(0xaaaaaa);
    scene.add(ambientLight);
    
    var ground = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshPhongMaterial({
        color: 0x555555,
        shininess: 1,
    }));
    ground.rotation.x = Math.PI * -0.5;
    scene.add(ground);
    
    var renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("c")
    });
    renderer.setSize(500, 500);
    renderer.setClearColor(0x000000);

    var parser = new vox.Parser();
    var parseTasks = [
        "vox/p1.vox",
        "vox/p2.vox",
        "vox/p3.vox",
        "vox/p4.vox",
        "vox/p5.vox",
        "vox/p6.vox",
        "vox/p7.vox",
        "vox/p8.vox",
        "vox/p9.vox",
        "vox/p10.vox",
        "vox/p11.vox",
        "vox/p12.vox",
    ].map(function(path) {
        return parser.parse(path);
    });
    Promise
        .all(parseTasks)
        .then(function(voxelDataArray) {
            voxelDataArray.forEach(function(voxelData, i) {
                var builder = new vox.MeshBuilder(voxelData, {
                    voxelSize: 1.2,
                    useMeshFaceMaterial: true,
                });
                var mesh = builder.createMesh();
                mesh.material.materials.forEach(function(m, i) {
                    if (i % 3 === 0) {
                        mesh.material.materials[i] = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            wireframe: true,
                            wireframeLinewidth: 0.1,
                        });
                    }
                });
                
                mesh.position.x = Math.random() * 100 - 50;
                mesh.position.z = Math.random() * 100 - 50;

                mesh.rotation.y = Math.random() * Math.PI * 2;
                
                var fv = new THREE.Vector3();
                updateListeners.push(function(frame) {
                    fv.set(0, 0, 0.1);
                    fv.applyQuaternion(mesh.quaternion);
                    mesh.position.add(fv);
                });
                
                scene.add(mesh);
            });
        });
    
    var frame = 0;
    var render = function() {
        update(frame++);
        renderer.render(scene, camera);
        requestAnimationFrame(render);
    };
    render();
};
</script>

</body>
</html>
